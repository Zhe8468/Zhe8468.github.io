<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="Zack Young">
    
    <title>
        
            算法竞赛模板 |
        
        Zack Young的个人网站
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
        <link rel="shortcut icon" href="/images/Zhe.jpg">
    
    
<link rel="stylesheet" href="/font/css/fontawesome.min.css">

    
<link rel="stylesheet" href="/font/css/regular.min.css">

    
<link rel="stylesheet" href="/font/css/solid.min.css">

    
<link rel="stylesheet" href="/font/css/brands.min.css">

    
    <script class="keep-theme-configurations">
    const KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"zh-CN"}
    KEEP.theme_config = {"base_info":{"primary_color":"#0066cc","title":"Zack Young的个人网站","author":"Zack Young","avatar":"/images/Zhe.jpg","logo":"/images/Zhe.jpg","favicon":"/images/Zhe.jpg"},"menu":{"home":"/","archives":"/archives","about":"/about"},"first_screen":{"enable":true,"background_img":"/images/bg.svg","background_img_dark":"/images/bg.svg","description":"Programming to change the world.","hitokoto":false},"social_contact":{"enable":true,"links":{"github":"https://github.com/Zhe8468","weixin":null,"qq":"3030357335","weibo":null,"zhihu":null,"twitter":null,"x":null,"facebook":null,"email":"zackyoung@163.com"}},"scroll":{"progress_bar":false,"percent":false,"hide_header":true},"home":{"announcement":null,"category":true,"tag":true,"post_datetime":"updated"},"post":{"author_badge":{"enable":true,"level_badge":false,"custom_badge":"菜鸟"},"word_count":{"wordcount":true,"min2read":true},"datetime_format":"YYYY-MM-DD HH:mm:ss","copyright_info":true,"share":true,"reward":{"enable":false,"img_link":null,"text":null,"icon":null}},"code_block":{"tools":{"enable":true,"style":"mac"},"highlight_theme":"obsidian"},"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true,"layout":"right"},"website_count":{"busuanzi_count":{"enable":false,"site_uv":true,"site_pv":true,"page_pv":true}},"local_search":{"enable":false,"preload":false},"comment":{"enable":false,"use":"valine","valine":{"appid":null,"appkey":null,"server_urls":null,"placeholder":null},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.36"},"waline":{"server_url":null,"reaction":false,"version":"3.2.1"},"giscus":{"repo":null,"repo_id":null,"category":"Announcements","category_id":null,"reactions_enabled":false},"artalk":{"server":null},"disqus":{"shortname":null}},"rss":{"enable":false},"lazyload":{"enable":false},"cdn":{"enable":false,"provider":"cdnjs"},"pjax":{"enable":false},"footer":{"since":2024,"word_count":false,"site_deploy":{"enable":true,"provider":"github","url":null},"record":{"enable":false,"list":[{"code":null,"link":null}]}},"inject":{"enable":false,"css":[null,"/css/custom.css"],"js":[null]},"root":"","source_data":{},"version":"4.2.3"}
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"}
    KEEP.language_code_block = {"copy":"复制代码","copied":"已复制","fold":"折叠代码块","folded":"已折叠"}
    KEEP.language_copy_copyright = {"copy":"复制版权信息","copied":"已复制","title":"原文标题","author":"原文作者","link":"原文链接"}
  </script>
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
<div class="progress-bar-container">
    

    
</div>



<main class="page-container border-box">
    <!-- home first screen  -->
    

    <!-- page content -->
    <div class="page-main-content border-box">
        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="border-box header-content">
        <div class="left flex-start border-box">
            
                <a class="logo-image border-box" href="/">
                    <img src="/images/Zhe.jpg">
                </a>
            
            <a class="site-name border-box" href="/">
               Zack Young的个人网站
            </a>
        </div>

        <div class="right border-box">
            <div class="pc border-box">
                <ul class="menu-list border-box">
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/">
                                
                                首页
                                
                            </a>
                            
                        </li>
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/archives">
                                
                                归档
                                
                            </a>
                            
                        </li>
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/about">
                                
                                关于
                                
                            </a>
                            
                        </li>
                    
                    
                </ul>
            </div>
            <div class="mobile border-box flex-start">
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list border-box">
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/">
                            
                            首页
                        </a>
                        
                    </label>
                    
                </li>
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/archives">
                            
                            归档
                        </a>
                        
                    </label>
                    
                </li>
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/about">
                            
                            关于
                        </a>
                        
                    </label>
                    
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle border-box">

            <div class="main-content border-box">
                

                    
<div class="fade-in-down-animation">
    <div class="post-page-container border-box">
        <div class="post-content-container border-box">
            

            <div class="post-content-bottom border-box">
                
                    <div class="post-title">
                        算法竞赛模板
                    </div>
                

                
                    <div class="post-header border-box">
                        
                            <div class="avatar-box border-box">
                                <img src="/images/Zhe.jpg">
                            </div>
                        
                        <div class="info-box">
                            <div class="author border-box">
                                <span class="name">Zack Young</span>
                                
                                    <span class="author-badge">菜鸟</span>
                                
                            </div>
                            <div class="meta-info border-box">
                                

<div class="post-meta-info-container border-box post">
    <div class="post-meta-info border-box">
        

        
            <span class="meta-info-item post-create-date">
                <i class="icon fa-solid fa-calendar-plus"></i>&nbsp;
                <span class="datetime">2024-11-21 19:59:34</span>
            </span>

            <span class="meta-info-item post-update-date">
                <i class="icon fa-solid fa-file-pen"></i>&nbsp;
                <span class="datetime" data-updated="Thu Nov 28 2024 20:38:23 GMT+0800">2024-11-28 20:38:23</span>
            </span>
        

        

        
            <span class="post-tag meta-info-item border-box">
                <ul class="post-tag-ul">
                    
                            <li class="tag-item"><span class="tag-separator"><i class="icon fas fa-hashtag"></i></span><a href="/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B-acm/">算法竞赛 acm</a></li>
                        
                    
                </ul>
            </span>
        

        
        
            <span class="meta-info-item post-wordcount">
                <i class="icon fas fa-file-word"></i>&nbsp;<span>6.1k 字</span>
            </span>
        
        
            <span class="meta-info-item post-min2read">
                <i class="icon fas fa-clock"></i>&nbsp;<span>33 分钟</span>
            </span>
        
        
    </div>

    
</div>

                            </div>
                        </div>
                    </div>
                

                <div class="post-content keep-markdown-body ">
                    

                    
                         <h1 id="算法竞赛模板"><a href="#算法竞赛模板" class="headerlink" title="算法竞赛模板"></a>算法竞赛模板</h1><h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><p>注意如果全局变量已经定义 在main里面就不要重复定义 否则会导致出现很多发现不了的错误</p>
<p>op不同输入就不同的题目 不要直接一次性读入全部(下面的错误写法)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line">    <span class="type">int</span> op,x,y,k;</span><br><span class="line">    cin&gt;&gt;op&gt;&gt;x&gt;&gt;y&gt;&gt;k;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">update</span>(<span class="number">1</span>,x,y,k);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">query</span>(<span class="number">1</span>,x,y)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快读"><a href="#快读" class="headerlink" title="快读"></a>快读</h2><blockquote>
<p> 如果卡常可以换成getchar_unlocked();<br> 如果遇到特别大的数据可以边读入边取模 常用模数P&#x3D;1e9+7</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ll w=<span class="number">1</span>,s=<span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span> || ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">			w*=<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ch=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">		s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		ch=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a,<span class="type">int</span> b,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">	ll res = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(b)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res=res*a%p;</span><br><span class="line">		a=a*a%p;</span><br><span class="line">		b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res%p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="欧拉线性筛法"><a href="#欧拉线性筛法" class="headerlink" title="欧拉线性筛法"></a>欧拉线性筛法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> primes[N],cnt; <span class="comment">//cnt表示质数的个数</span></span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="comment">//x是要筛的范围</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=x;i++)&#123;</span><br><span class="line">        <span class="comment">//没有被筛过 说明是质数</span></span><br><span class="line">		<span class="keyword">if</span>(!st[i]) primes[++cnt]=i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;primes[j]*i&lt;=x;j++)&#123;</span><br><span class="line">			st[primes[j]*i]=<span class="literal">true</span>; <span class="comment">//标记质数</span></span><br><span class="line">			<span class="keyword">if</span>(primes[j]%i==<span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">//退出</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="秦九韶算法"><a href="#秦九韶算法" class="headerlink" title="秦九韶算法"></a>秦九韶算法</h3><p>用于计算多项式的值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	ll tot = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">		tot=((tot+a[i])*x)%P;</span><br><span class="line">	&#125;</span><br><span class="line">	tot=(tot+a[<span class="number">0</span>])%P; <span class="comment">//注意a0前面没有x</span></span><br><span class="line">	<span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><p>几个板子（推荐用第一个板子）</p>
<p><img   src="C:\Users\13553\AppData\Roaming\Typora\typora-user-images\image-20241113172716270.png"  alt="image-20241113172716270"></p>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p><img   src="C:\Users\13553\AppData\Roaming\Typora\typora-user-images\image-20241127182631973.png"  alt="image-20241127182631973"></p>
<h2 id="单调队列-滑动窗口"><a href="#单调队列-滑动窗口" class="headerlink" title="单调队列&#x2F;滑动窗口"></a>单调队列&#x2F;滑动窗口</h2><p>对头队尾都可以出队的队列</p>
<h4 id="维护窗口的最小值"><a href="#维护窗口的最小值" class="headerlink" title="维护窗口的最小值"></a>维护窗口的最小值</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hh=<span class="number">1</span>,tt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(hh&lt;=tt&amp;&amp;a[i]&lt;a[q[tt]]) tt--;</span><br><span class="line">    q[++tt]=i;</span><br><span class="line">    <span class="keyword">if</span>(q[hh]&lt;i-k<span class="number">+1</span>) hh++;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;=k) cout&lt;&lt;a[q[hh]]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="维护窗口的最大值"><a href="#维护窗口的最大值" class="headerlink" title="维护窗口的最大值"></a>维护窗口的最大值</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hh=<span class="number">1</span>,tt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(hh&lt;=tt&amp;&amp;a[i]&gt;a[q[tt]]) tt--;</span><br><span class="line">    q[++tt]=i;</span><br><span class="line">    <span class="keyword">if</span>(q[hh]&lt;i-k<span class="number">+1</span>) hh++;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;=k) cout&lt;&lt;a[q[hh]]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h2><h3 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h3><blockquote>
<p>a和b需要字符串倒序存储到vector里面，注意运算之后的结果要倒序输出</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a,vector&lt;<span class="type">int</span>&gt;&amp; b)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; c;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>()||i&lt;b.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;a.<span class="built_in">size</span>()) t+=a[i];</span><br><span class="line">		<span class="keyword">if</span>(i&lt;b.<span class="built_in">size</span>()) t+=b[i];</span><br><span class="line">		c.<span class="built_in">push_back</span>(t%<span class="number">10</span>);</span><br><span class="line">		t/=<span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(t) c.<span class="built_in">push_back</span>(t);</span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h3><blockquote>
<p>a和b需要字符串倒序存储到vector里面，注意运算之后的结果要倒序输出</p>
<p>做减法之前要先判断一下两个数字的大小 然后交换两个数字 保证a是大于b的</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">cmp</span>(aa,bb)) <span class="built_in">swap</span>(aa,bb), cout&lt;&lt;<span class="string">&quot;-&quot;</span>;</span><br><span class="line"><span class="comment">//比较函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a,vector&lt;<span class="type">int</span>&gt;&amp; b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a.<span class="built_in">size</span>()!=b.<span class="built_in">size</span>()) <span class="keyword">return</span> a.<span class="built_in">size</span>()&gt;b.<span class="built_in">size</span>();</span><br><span class="line">	<span class="comment">//能进入下面说明长度相等</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=a.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i]!=b[i]) <span class="keyword">return</span> a[i]&gt;b[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果两个相等 也返回一个true 防止出现-0</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a,vector&lt;<span class="type">int</span>&gt;&amp; b)</span></span>&#123;</span><br><span class="line">	<span class="comment">//此时已经保证a&gt;b</span></span><br><span class="line">	<span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; c;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">		t=a[i];</span><br><span class="line">		<span class="keyword">if</span>(i&lt;b.<span class="built_in">size</span>()) t-=b[i];</span><br><span class="line">		<span class="keyword">if</span>(t&lt;<span class="number">0</span>) a[i<span class="number">+1</span>]--,t+=<span class="number">10</span>;</span><br><span class="line">		c.<span class="built_in">push_back</span>(t);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//消除前导0</span></span><br><span class="line">	<span class="keyword">while</span>(c.<span class="built_in">size</span>()&gt;<span class="number">1</span>&amp;&amp;c.<span class="built_in">back</span>()==<span class="number">0</span>) c.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h3><blockquote>
<p>a和b需要字符串倒序存储到vector里面，注意运算之后的结果要倒序输出</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a,vector&lt;<span class="type">int</span>&gt;&amp; b)</span></span>&#123;</span><br><span class="line">	<span class="comment">//c的大小是两个长度的和</span></span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(a.size()+b.size())</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;b.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">			c[i+j] += a[i]*b[j];</span><br><span class="line">			c[i+j<span class="number">+1</span>] += c[i+j]/<span class="number">10</span>;</span><br><span class="line">			c[i+j]%=<span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//消除前导0</span></span><br><span class="line">	<span class="keyword">while</span>(c.<span class="built_in">size</span>()&gt;<span class="number">1</span>&amp;&amp;c.<span class="built_in">back</span>()==<span class="number">0</span>) c.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="高精度除以低精度"><a href="#高精度除以低精度" class="headerlink" title="高精度除以低精度"></a>高精度除以低精度</h3><blockquote>
<p>vector a不需要倒序存储 正序存储就可以   b是低精度整数<br>最终计算结果是倒序的</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	ll r=<span class="number">0</span>;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; c;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">		r=r*<span class="number">10</span>+a[i];</span><br><span class="line">		c.<span class="built_in">push_back</span>(r/b);</span><br><span class="line">		r%=b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">reverse</span>(c.<span class="built_in">begin</span>(),c.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">while</span>(c.<span class="built_in">size</span>()&gt;<span class="number">1</span>&amp;&amp;c.<span class="built_in">back</span>()==<span class="number">0</span>) c.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><blockquote>
<p>注意匹配的两个字符串都需要从下标1开始 可以通过s&#x3D;” “+s的方法来操作</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求next</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=m;i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;s2[j<span class="number">+1</span>]!=s2[i]) j=ne[j];</span><br><span class="line">    <span class="keyword">if</span>(s2[j<span class="number">+1</span>]==s2[i]) j++;</span><br><span class="line">    ne[i]=j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//kmp</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;s1[i]!=s2[j<span class="number">+1</span>]) j=ne[j];</span><br><span class="line">    <span class="keyword">if</span>(s1[i]==s2[j<span class="number">+1</span>]) j++;</span><br><span class="line">    <span class="keyword">if</span>(j==m) cout&lt;&lt;i-m<span class="number">+1</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h2><blockquote>
<p>哈希的初始化建议放在最开始并且初始化次数越少越好</p>
<p>对于p数组的初始化 一定要看清楚需要初始化的位数</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> P = <span class="number">131</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line">ull p[<span class="number">10010</span>],h[<span class="number">10010</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(string&amp; s)</span></span>&#123;</span><br><span class="line">    p[<span class="number">0</span>]=<span class="number">1</span>,h[<span class="number">0</span>]=<span class="number">0</span>; <span class="comment">//p是用来存储P的次方的 h是用来存储哈希值的</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        p[i]=p[i<span class="number">-1</span>]*P; </span><br><span class="line">        h[i]=h[i<span class="number">-1</span>]*P+s[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取指定区间的哈希值</span></span><br><span class="line"><span class="function">ull <span class="title">get</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r]-h[l<span class="number">-1</span>]*p[r-l<span class="number">+1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="链式前向星存图"><a href="#链式前向星存图" class="headerlink" title="链式前向星存图"></a>链式前向星存图</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e3</span><span class="number">+10</span>; <span class="comment">//点的数量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">6e3</span><span class="number">+10</span>; <span class="comment">//边的数量</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">	<span class="type">int</span> v,w,to; <span class="comment">//v是目标点 w是边权 to是下一条边的编号</span></span><br><span class="line">&#125;e[M];</span><br><span class="line"><span class="comment">//h是每个点指向的第一条边的编号 </span></span><br><span class="line"><span class="comment">//vis标记是否在队列里面</span></span><br><span class="line"><span class="comment">//cnt标记每个点的边数目</span></span><br><span class="line"><span class="comment">//idx表示边的编号</span></span><br><span class="line"><span class="type">int</span> h[N],vis[N],dist[N],cnt[N],idx; </span><br><span class="line"><span class="comment">//h初始化为-1要放在建边之前！！！</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">	e[idx]=&#123;v,w,h[u]&#125;;</span><br><span class="line">	h[u]=idx++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果有多组数据 记得输入之前要把h,vis,dist,cnt清空</p>
<p>也不能忘记把idx重新置为0</p>
</blockquote>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><h3 id="Kahn-卡恩-算法"><a href="#Kahn-卡恩-算法" class="headerlink" title="Kahn(卡恩)算法"></a>Kahn(卡恩)算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建图</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N],tp;</span><br><span class="line"><span class="type">int</span> n,de[N];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    e[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拓扑排序</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">toposort</span><span class="params">()</span></span>&#123;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(de[i]==<span class="number">0</span>) q.<span class="built_in">push</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">		<span class="type">int</span> t=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">		tp.<span class="built_in">push_back</span>(t);</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">auto</span> ele:e[t])&#123;</span><br><span class="line">             <span class="keyword">if</span>(--de[ele]==<span class="number">0</span>) q.<span class="built_in">push</span>(ele);</span><br><span class="line">         &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tp.<span class="built_in">size</span>()==n; <span class="comment">//个数小于n则存在环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> T;</span><br><span class="line">cin&gt;&gt;T;</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line">    idx=<span class="number">0</span>; <span class="comment">//关键</span></span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="built_in">sizeof</span>(h)); <span class="comment">//关键</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果需要记录拓扑排序的深度 那么可以开一个结构体 然后将queue和tp都改成结构体的类型 将层数记录到结构体里面去</p>
</blockquote>
<h2 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h2><p><strong>有时候0x3f会被卡 要看情况</strong></p>
<p>如果遇到起程是单源到多源 返程变成多源到单源的题目 可以进行反向建边操作 同时需要注意边和点都需要扩大到原来的两倍</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">    <span class="type">int</span> u,v,w;</span><br><span class="line">    cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">    <span class="built_in">add</span>(u,v,w);</span><br><span class="line">    <span class="built_in">add</span>(v+n,u+n,w); <span class="comment">//比如有一条5-&gt;1 建成1-&gt;5 为了不干扰原来的边 将每个点都加n</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">djikstra</span>(n<span class="number">+1</span>) <span class="comment">//从n+1开始 其实也可以理解为从1开始</span></span><br></pre></td></tr></table></figure>

<h3 id="单源最短路-Djikstra"><a href="#单源最短路-Djikstra" class="headerlink" title="单源最短路- Djikstra"></a>单源最短路- Djikstra</h3><blockquote>
<p>不能处理负边权<br>优先队列默认是对pair的first进行排序 所以first存边权<br>priority_queue默认是大根堆 可以用负数的方式来实现小根堆</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链式前向星模板</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">	<span class="type">int</span> v,w,to;</span><br><span class="line">&#125;e[M];</span><br><span class="line"><span class="type">int</span> h[N],dist[N],vis[N],idx;</span><br><span class="line"><span class="type">int</span> n,m,s;</span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; q; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">	e[idx]=&#123;v,w,h[u]&#125;;</span><br><span class="line">	h[u]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">djikstra</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dist)); <span class="comment">//注意清空</span></span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">	q.<span class="built_in">push</span>(&#123;<span class="number">0</span>,s&#125;);dist[s]=<span class="number">0</span>; <span class="comment">//此处不要写vis[s]=true 不然第一个点被选到了就跳过了</span></span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">		<span class="keyword">auto</span> t=q.<span class="built_in">top</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="type">int</span> u=t.second;  <span class="comment">//这里不要写成q.second</span></span><br><span class="line">		<span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>; <span class="comment">//注意vis要写在这里而不是下面</span></span><br><span class="line">		vis[u]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=h[u];i!=<span class="number">-1</span>;i=e[i].to)&#123;</span><br><span class="line">			<span class="type">int</span> v=e[i].v,w=e[i].w;</span><br><span class="line">			<span class="keyword">if</span>(dist[v]&gt;dist[u]+w)&#123;</span><br><span class="line">				dist[v]=dist[u]+w;</span><br><span class="line">				q.<span class="built_in">push</span>(&#123;-dist[v],v&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img   src="C:\Users\13553\AppData\Roaming\Typora\typora-user-images\image-20241113194559179.png"  alt="image-20241113194559179"></p>
<h3 id="单源最短路-Spfa"><a href="#单源最短路-Spfa" class="headerlink" title="单源最短路- Spfa"></a>单源最短路- Spfa</h3><blockquote>
<p>spfa最坏情况下会退化成Bellman-ford算法 O(NM) 很容易被卡</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> s,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//必要的初始化 防止多次输入数据忘了清空</span></span><br><span class="line">	<span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dist));</span><br><span class="line">	<span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt));</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">	dist[s]=<span class="number">0</span>;q.<span class="built_in">push</span>(s);vis[s]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">		<span class="type">int</span> u=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();vis[u]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=h[u];i!=<span class="number">-1</span>;i=e[i].to)&#123;</span><br><span class="line">			<span class="type">int</span> v=e[i].v,w=e[i].w;</span><br><span class="line">			<span class="keyword">if</span>(dist[u]+w&lt;dist[v])&#123;</span><br><span class="line">				dist[v]=dist[u]+w;</span><br><span class="line">				cnt[v]=cnt[u]<span class="number">+1</span>;</span><br><span class="line">				<span class="keyword">if</span>(cnt[v]&gt;=n) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//已经存在负环</span></span><br><span class="line">				<span class="keyword">if</span>(!vis[v])&#123; <span class="comment">//已经更新并且没有在队列里面那么就可以再次入队</span></span><br><span class="line">					q.<span class="built_in">push</span>(v),vis[v]=<span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="全源最短路-Floyd"><a href="#全源最短路-Floyd" class="headerlink" title="全源最短路-Floyd"></a>全源最短路-Floyd</h3><blockquote>
<p>基于动态规划算法实现的全源最短路<br>时间复杂度是O(n^3)</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建图</span></span><br><span class="line"><span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dist));</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==j) dist[i][j]=dist[j][i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">    <span class="type">int</span> u,v,w;</span><br><span class="line">    cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">    dist[u][v]=<span class="built_in">min</span>(dist[u][v],w);</span><br><span class="line">    dist[v][u]=<span class="built_in">min</span>(dist[v][u],w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//floyd</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">				dist[i][j]=<span class="built_in">min</span>(dist[i][j],dist[i][k]+dist[k][j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>如果要将k个点连成k个连通块 那么需要连n-k条边<br>在加边的时候如果已经等于需要的数目就可以break掉了</p>
<p>如果遇到一开始有边 然后需要加边加到能够生成最小生成树的题目 可以在读入点之后 双层循环给每个点之间加边，然后再将题目中已经有的边加入(边权初始化为0)，接着继续最小生成树就可以了 例：[P2872 <a class="link"   target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2872" >USACO07DEC] Building Roads S - 洛谷 | 计算机科学教育新生态<i class="fas fa-external-link-alt"></i></a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">    <span class="type">int</span> u=e[i].u,v=e[i].v,w=e[i].w;</span><br><span class="line">    <span class="type">int</span> x=<span class="built_in">find</span>(u),y=<span class="built_in">find</span>(v);</span><br><span class="line">    <span class="keyword">if</span>(x!=y)&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        ans+=w;</span><br><span class="line">        <span class="keyword">if</span>(cn==n-k) <span class="keyword">break</span>; <span class="comment">//这个地方要放在ans累加的后面</span></span><br><span class="line">        <span class="built_in">merge</span>(x,y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt==n-k;</span><br></pre></td></tr></table></figure>

<h3 id="Prim算法（加点法）"><a href="#Prim算法（加点法）" class="headerlink" title="Prim算法（加点法）"></a>Prim算法（加点法）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> u,v,w,ne;</span><br><span class="line">&#125;e[M];</span><br><span class="line"><span class="type">int</span> idx,n,m,h[N],dist[N],ans,cnt;</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line">priority_queue&lt;PII&gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">    e[idx]=&#123;u,v,w,h[u]&#125;;</span><br><span class="line">    h[u]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">prim</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dist[i]=inf;</span><br><span class="line">    dist[s]=<span class="number">0</span>; q.<span class="built_in">push</span>(&#123;<span class="number">0</span>,s&#125;);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">top</span>().second;q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[u]=<span class="literal">true</span>;</span><br><span class="line">        ans+=dist[u]; cnt++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=h[u];i!=<span class="number">-1</span>;i=e[i].ne)&#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].v,w=e[i].w;</span><br><span class="line">            <span class="keyword">if</span>(dist[v]&gt;w)&#123;</span><br><span class="line">                dist[v]=w; </span><br><span class="line">                q.<span class="built_in">push</span>(&#123;-dist[v],v&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt==n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//建边</span></span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="built_in">sizeof</span>(h));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">    <span class="type">int</span> u,v,w;</span><br><span class="line">    cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">    <span class="built_in">add</span>(u,v,w);</span><br><span class="line">    <span class="built_in">add</span>(v,u,w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Kruskal算法（加边法）"><a href="#Kruskal算法（加边法）" class="headerlink" title="Kruskal算法（加边法）"></a>Kruskal算法（加边法）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> u,v,w;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> edge&amp; a) <span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w&lt;a.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[M];</span><br><span class="line"><span class="type">int</span> n,m,fa[N];</span><br><span class="line">ll ans,cnt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x]==x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x]=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用之前要先排序</span></span><br><span class="line"><span class="built_in">sort</span>(e<span class="number">+1</span>,e+m<span class="number">+1</span>);</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fa[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x=<span class="built_in">find</span>(e[i].u),y=<span class="built_in">find</span>(e[i].v);</span><br><span class="line">        <span class="keyword">if</span>(x!=y)&#123;</span><br><span class="line">            fa[x]=y;</span><br><span class="line">            cnt++;</span><br><span class="line">            ans+=e[i].w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt==n<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h4 id="普通并查集"><a href="#普通并查集" class="headerlink" title="普通并查集"></a>普通并查集</h4><p>注意并查集题目中有些建边操作是双向的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> fa[N]; <span class="comment">//fa存储每个元素的根节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123; <span class="comment">//查找的过程中进行路径压缩 每次查找完成之后会对子节点进行路径压缩</span></span><br><span class="line">	<span class="keyword">if</span>(fa[x]==x) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> fa[x]=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123; <span class="comment">//合并两个集合</span></span><br><span class="line">	fa[<span class="built_in">find</span>(x)] = <span class="built_in">find</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化 非常重要</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fa[i]=i;</span><br></pre></td></tr></table></figure>

<h4 id="扩展域并查集"><a href="#扩展域并查集" class="headerlink" title="扩展域并查集"></a>扩展域并查集</h4><p>在原有的$(1,n)$的基础上扩充到$(n+1,2n)$<br>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">现在有 n 个人，他们之间有两种关系：朋友和敌人。</span><br><span class="line">一个人的朋友的朋友是朋友</span><br><span class="line">一个人的敌人的敌人是朋友</span><br></pre></td></tr></table></figure>

<p>若a与b是朋友 则直接合并a b<br>若a与b是敌人 则合并a与b+n 合并b与a+n<br>&#x3D;&#x3D;最后统计$(1,n)$内的集合的个数就是答案&#x3D;&#x3D;</p>
<h4 id="带权并查集"><a href="#带权并查集" class="headerlink" title="带权并查集"></a>带权并查集</h4><h2 id="堆-priority-queue"><a href="#堆-priority-queue" class="headerlink" title="堆 priority_queue"></a>堆 priority_queue</h2><p>自己实现的结构体 放在堆里面要自己重载一下小于号来实现大根堆</p>
<h3 id="成员函数内部重载"><a href="#成员函数内部重载" class="headerlink" title="成员函数内部重载"></a>成员函数内部重载</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">number</span>&#123;</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> number&amp; a) <span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s&lt;a.s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;number&gt; pq;</span><br></pre></td></tr></table></figure>

<h3 id="外部重载"><a href="#外部重载" class="headerlink" title="外部重载"></a>外部重载</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">number</span>&#123;</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> number&amp;x,<span class="type">const</span> number&amp; y)&#123;</span><br><span class="line">    <span class="keyword">return</span> x.s&lt;y.s;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;number&gt; pq;</span><br></pre></td></tr></table></figure>

<h3 id="小根堆"><a href="#小根堆" class="headerlink" title="小根堆"></a>小根堆</h3><p>重载大于号</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">number</span>&#123;</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> number&amp;x,<span class="type">const</span> number&amp; y)&#123;</span><br><span class="line">    <span class="keyword">return</span> x.s&gt;y.s;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;number,vector&lt;number&gt;,greater&lt;number&gt;&gt; pq;</span><br></pre></td></tr></table></figure>

<h3 id="对顶堆"><a href="#对顶堆" class="headerlink" title="对顶堆"></a>对顶堆</h3><h4 id="第k大"><a href="#第k大" class="headerlink" title="第k大"></a>第k大</h4><p>小根堆的堆顶就是第k大的数字</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pq1小根堆 pq2大根堆</span></span><br><span class="line"><span class="keyword">if</span>(pq<span class="number">1.</span><span class="built_in">empty</span>()||x&gt;=pq<span class="number">1.</span><span class="built_in">top</span>()) pq<span class="number">1.</span><span class="built_in">push</span>(x);</span><br><span class="line"><span class="keyword">else</span> pq<span class="number">2.</span><span class="built_in">push</span>(x);</span><br><span class="line"><span class="keyword">while</span>(pq<span class="number">1.</span><span class="built_in">size</span>()&gt;k) pq<span class="number">2.</span><span class="built_in">push</span>(pq<span class="number">1.</span><span class="built_in">top</span>()), pq<span class="number">1.</span><span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">while</span>(pq<span class="number">1.</span><span class="built_in">size</span>()&lt;k) pq<span class="number">1.</span><span class="built_in">push</span>(pq<span class="number">2.</span><span class="built_in">top</span>()), pq<span class="number">2.</span><span class="built_in">pop</span>();</span><br><span class="line"><span class="comment">//pq1.top() 就是第k大的数字</span></span><br></pre></td></tr></table></figure>

<h4 id="第k小"><a href="#第k小" class="headerlink" title="第k小"></a>第k小</h4><p>大根堆里面存储小于等于答案的数 小根堆里面存储大于答案的数 大根堆的堆顶就是第k小的数字</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pq2 大根堆 pq1小根堆</span></span><br><span class="line"><span class="keyword">if</span>(pq<span class="number">2.</span><span class="built_in">empty</span>()||x&lt;=pq<span class="number">2.</span><span class="built_in">top</span>()) pq<span class="number">2.</span><span class="built_in">push</span>(x);</span><br><span class="line"><span class="keyword">else</span> pq<span class="number">1.</span><span class="built_in">push</span>(x);</span><br><span class="line"><span class="keyword">while</span>(pq<span class="number">2.</span><span class="built_in">size</span>()&gt;k) pq<span class="number">1.</span><span class="built_in">push</span>(pq<span class="number">2.</span><span class="built_in">top</span>()), pq<span class="number">2.</span><span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">while</span>(pq<span class="number">2.</span><span class="built_in">size</span>()&lt;k) pq<span class="number">2.</span><span class="built_in">push</span>(pq<span class="number">1.</span><span class="built_in">top</span>()), pq<span class="number">1.</span><span class="built_in">pop</span>();</span><br><span class="line"><span class="comment">//pq2.top() 就是第k小的数字</span></span><br></pre></td></tr></table></figure>

<h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><p><strong>线段树要记得开4*N的大小 不然会RE</strong></p>
<h4 id="普通线段树"><a href="#普通线段树" class="headerlink" title="普通线段树"></a>普通线段树</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> lc p&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc p&lt;&lt;1|1</span></span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    ll l,r,sum,lazy;</span><br><span class="line">&#125;tree[<span class="number">4</span>*N]; <span class="comment">//需要四倍空间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span></span>&#123; <span class="comment">//更新自己</span></span><br><span class="line">    tree[p].sum=tree[lc].sum+tree[rc].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> p)</span></span>&#123; <span class="comment">//向下传递懒标记</span></span><br><span class="line">    tree[lc].sum += (tree[lc].r-tree[lc].l<span class="number">+1</span>)*tree[p].lazy;</span><br><span class="line">    tree[rc].sum += (tree[rc].r-tree[rc].l<span class="number">+1</span>)*tree[p].lazy;</span><br><span class="line">    tree[lc].lazy+=tree[p].lazy;</span><br><span class="line">    tree[rc].lazy+=tree[p].lazy;</span><br><span class="line">    tree[p].lazy=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123; <span class="comment">//递归建树</span></span><br><span class="line">    tree[p]=&#123;l,r,a[l],<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(lc,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(rc,mid<span class="number">+1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> k)</span></span>&#123;<span class="comment">//将区间[x,y]的所有数加k</span></span><br><span class="line">    <span class="keyword">if</span>(x&lt;=tree[p].l&amp;&amp;y&gt;=tree[p].r)&#123;</span><br><span class="line">        tree[p].sum+=(tree[p].r-tree[p].l<span class="number">+1</span>)*k;</span><br><span class="line">        tree[p].lazy+=k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(tree[p].l+tree[p].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">update</span>(lc,x,y,k);</span><br><span class="line">    <span class="keyword">if</span>(y&gt;mid) <span class="built_in">update</span>(rc,x,y,k);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="comment">//查询区间[x,y]的所有数的和</span></span><br><span class="line">    <span class="keyword">if</span>(x&lt;=tree[p].l&amp;&amp;y&gt;=tree[p].r)&#123;</span><br><span class="line">        <span class="keyword">return</span> tree[p].sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=tree[p].l+tree[p].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">pushdown</span>(p);</span><br><span class="line">    ll tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) tot+=<span class="built_in">query</span>(lc,x,y);</span><br><span class="line">    <span class="keyword">if</span>(y&gt;mid) tot+=<span class="built_in">query</span>(rc,x,y);</span><br><span class="line">    <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="带乘法的线段树"><a href="#带乘法的线段树" class="headerlink" title="带乘法的线段树"></a>带乘法的线段树</h4><p>先乘再加 <strong>注意不要把l和1写错</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc p&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc p&lt;&lt;1|1</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    ll sum,mul,add;</span><br><span class="line">&#125;tree[N*<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> n,m,q,w[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calc</span><span class="params">(node &amp;t,ll mul,ll add)</span></span>&#123;</span><br><span class="line">  t.sum=(t.sum*mul+(t.r-t.l<span class="number">+1</span>)*add)%m;</span><br><span class="line">  t.mul=t.mul*mul%m;</span><br><span class="line">  t.add=(t.add*mul+add)%m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    tree[p].sum=(tree[lc].sum+tree[rc].sum)%m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="built_in">calc</span>(tree[lc],tree[p].mul,tree[p].add);</span><br><span class="line">    <span class="built_in">calc</span>(tree[rc],tree[p].mul,tree[p].add);</span><br><span class="line">    tree[p].mul=<span class="number">1</span>;</span><br><span class="line">    tree[p].add=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    tree[p]=&#123;l,r,w[r],<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(lc,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(rc,mid<span class="number">+1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> x,<span class="type">int</span> y,ll mul,ll add)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[p].l&gt;=x&amp;&amp;tree[p].r&lt;=y)&#123;</span><br><span class="line">        <span class="built_in">calc</span>(tree[p],mul,add);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=tree[p].l+tree[p].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">update</span>(lc,x,y,mul,add);</span><br><span class="line">    <span class="keyword">if</span>(y&gt;mid) <span class="built_in">update</span>(rc,x,y,mul,add);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[p].l&gt;=x&amp;&amp;tree[p].r&lt;=y)&#123;</span><br><span class="line">        <span class="keyword">return</span> tree[p].sum%m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="type">int</span> mid=tree[p].l+tree[p].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    ll tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) tot+=<span class="built_in">query</span>(lc,x,y)%m;</span><br><span class="line">    <span class="keyword">if</span>(y&gt;mid) tot+=<span class="built_in">query</span>(rc,x,y)%m;</span><br><span class="line">    <span class="keyword">return</span> tot%m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="求多段区间内不同元素的个数"><a href="#求多段区间内不同元素的个数" class="headerlink" title="求多段区间内不同元素的个数"></a>求多段区间内不同元素的个数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span><span class="number">+10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc p&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc p&lt;&lt;1|1</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    ll sum,add;</span><br><span class="line">&#125;tree[N*<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> a[N],last[N];</span><br><span class="line">PII q[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; b[N];</span><br><span class="line">ll ans[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    tree[p].sum=tree[lc].sum+tree[rc].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    tree[lc].sum+=(tree[lc].r-tree[lc].l<span class="number">+1</span>)*tree[p].add;</span><br><span class="line">    tree[rc].sum+=(tree[rc].r-tree[rc].l<span class="number">+1</span>)*tree[p].add;</span><br><span class="line">    tree[lc].add+=tree[p].add;</span><br><span class="line">    tree[rc].add+=tree[p].add;</span><br><span class="line">    tree[p].add=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    tree[p]=&#123;l,r,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(lc,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(rc,mid<span class="number">+1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[p].l==x&amp;&amp;tree[p].r==x)&#123;</span><br><span class="line">        tree[p].sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=tree[p].l+tree[p].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">pushdown</span>(p);</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">update</span>(lc,x);</span><br><span class="line">    <span class="keyword">if</span>(x&gt;mid) <span class="built_in">update</span>(rc,x);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[p].l&gt;=x&amp;&amp;tree[p].r&lt;=y)&#123;</span><br><span class="line">        <span class="keyword">return</span> tree[p].sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=tree[p].l+tree[p].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    ll tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) tot+=<span class="built_in">query</span>(lc,x,y);</span><br><span class="line">    <span class="keyword">if</span>(y&gt;mid) tot+=<span class="built_in">query</span>(rc,x,y);</span><br><span class="line">    <span class="keyword">return</span> tot;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        q[i]=&#123;l,r&#125;;</span><br><span class="line">        b[r].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(last[a[i]]) <span class="built_in">update</span>(<span class="number">1</span>,last[a[i]]);</span><br><span class="line">        last[a[i]]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ele:b[i])&#123;</span><br><span class="line">            ans[ele]=<span class="built_in">query</span>(<span class="number">1</span>,q[ele].first,q[ele].second);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="权值线段树"><a href="#权值线段树" class="headerlink" title="权值线段树"></a>权值线段树</h4><p>一开始建树的时候将叶子节点的值全部初始化为0 然后每次进行单点修改 单点修改不需要懒标记</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc p&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc p&lt;&lt;1|1</span></span><br><span class="line"><span class="type">int</span> a[N],b[N];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    ll sum,add;</span><br><span class="line">&#125;tree[N*<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    tree[p].sum=tree[lc].sum+tree[rc].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    tree[p]=&#123;l,r,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(lc,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(rc,mid<span class="number">+1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[p].l==x&amp;&amp;tree[p].r==x)&#123;</span><br><span class="line">        tree[p].sum++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(tree[p].l+tree[p].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">update</span>(lc,x);</span><br><span class="line">    <span class="keyword">if</span>(x&gt;mid) <span class="built_in">update</span>(rc,x);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[p].l&gt;=x&amp;&amp;tree[p].r&lt;=y)&#123;</span><br><span class="line">        <span class="keyword">return</span> tree[p].sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=tree[p].l+tree[p].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    ll tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) tot+=<span class="built_in">query</span>(lc,x,y);</span><br><span class="line">    <span class="keyword">if</span>(y&gt;mid) tot+=<span class="built_in">query</span>(rc,x,y);</span><br><span class="line">    <span class="keyword">return</span> tot; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i],b[i]=a[i];</span><br><span class="line">    <span class="comment">//离散化</span></span><br><span class="line">    <span class="built_in">sort</span>(b<span class="number">+1</span>,b+n<span class="number">+1</span>);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> id=<span class="built_in">lower_bound</span>(b<span class="number">+1</span>,b+n<span class="number">+1</span>,a[i])-b;</span><br><span class="line">        <span class="built_in">update</span>(<span class="number">1</span>,id);</span><br><span class="line">        ans+=<span class="built_in">query</span>(<span class="number">1</span>,id<span class="number">+1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="区间最大子段和"><a href="#区间最大子段和" class="headerlink" title="区间最大子段和"></a>区间最大子段和</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc p&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc p&lt;&lt;1|1</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">50010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,q,a[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    ll sum,mx,lmx,rmx;</span><br><span class="line">&#125;tree[N*<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(Tree&amp; P,Tree L,Tree R)</span></span>&#123;</span><br><span class="line">    P.sum=L.sum+R.sum;</span><br><span class="line">    P.lmx=<span class="built_in">max</span>(L.lmx,L.sum+R.lmx);</span><br><span class="line">    P.rmx=<span class="built_in">max</span>(R.rmx,R.sum+L.rmx);</span><br><span class="line">    P.mx=<span class="built_in">max</span>(<span class="built_in">max</span>(L.mx,R.mx),L.rmx+R.lmx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    tree[p]=&#123;l,r,a[l],a[l],a[l],a[l]&#125;;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(lc,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(rc,mid<span class="number">+1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(tree[p],tree[lc],tree[rc]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> x,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[p].l==x&amp;&amp;tree[p].r==x)&#123;</span><br><span class="line">        tree[p]=&#123;x,x,k,k,k,k&#125;;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=tree[p].l+tree[p].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">update</span>(lc,x,k);</span><br><span class="line">    <span class="keyword">if</span>(x&gt;mid) <span class="built_in">update</span>(rc,x,k);</span><br><span class="line">    <span class="built_in">pushup</span>(tree[p],tree[lc],tree[rc]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Tree <span class="title">query</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[p].l&gt;=x&amp;&amp;tree[p].r&lt;=y)&#123;</span><br><span class="line">        <span class="keyword">return</span> tree[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=tree[p].l+tree[p].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;x) <span class="keyword">return</span> <span class="built_in">query</span>(rc,x,y);</span><br><span class="line">    <span class="keyword">if</span>(mid&gt;=y) <span class="keyword">return</span> <span class="built_in">query</span>(lc,x,y);</span><br><span class="line">    Tree T;</span><br><span class="line">    <span class="built_in">pushup</span>(T,<span class="built_in">query</span>(lc,x,mid),<span class="built_in">query</span>(rc,mid<span class="number">+1</span>,y));</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    cin&gt;&gt;q;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="type">int</span> op,x,y;</span><br><span class="line">        cin&gt;&gt;op&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">update</span>(<span class="number">1</span>,x,y);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="built_in">query</span>(<span class="number">1</span>,x,y).mx&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="拆位线段树"><a href="#拆位线段树" class="headerlink" title="拆位线段树"></a>拆位线段树</h4><p>使用二进制位运算 将每一个数都转换为二进制 然后把每一位都建一颗线段树 统计每一个线段树里面指定区间l r内1的个数就可以实现求和</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc p&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc p&lt;&lt;1|1</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,m,a[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">segment_tree</span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tree</span>&#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        ll sum,add;</span><br><span class="line">    &#125;tr[N*<span class="number">4</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">        tr[p].sum=tr[lc].sum+tr[rc].sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[p].add)&#123;</span><br><span class="line">            tr[lc].sum=(tr[lc].r-tr[lc].l<span class="number">+1</span>)-tr[lc].sum;</span><br><span class="line">            tr[rc].sum=(tr[rc].r-tr[rc].l<span class="number">+1</span>)-tr[rc].sum;</span><br><span class="line">            tr[lc].add^=<span class="number">1</span>,tr[rc].add^=<span class="number">1</span>;</span><br><span class="line">            tr[p].add=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        tr[p]=&#123;l,r,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[l]&gt;&gt;x&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                tr[p].sum=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(lc,l,mid,x);</span><br><span class="line">        <span class="built_in">build</span>(rc,mid<span class="number">+1</span>,r,x);</span><br><span class="line">        <span class="built_in">pushup</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[p].l&gt;=l&amp;&amp;tr[p].r&lt;=r)&#123;</span><br><span class="line">            tr[p].sum=(tr[p].r-tr[p].l<span class="number">+1</span>)-tr[p].sum;</span><br><span class="line">            tr[p].add^=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid=tr[p].l+tr[p].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">pushdown</span>(p);</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=mid) <span class="built_in">update</span>(lc,l,r);</span><br><span class="line">        <span class="keyword">if</span>(r&gt;mid) <span class="built_in">update</span>(rc,l,r);</span><br><span class="line">        <span class="built_in">pushup</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[p].l&gt;=l&amp;&amp;tr[p].r&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">return</span> tr[p].sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid=tr[p].l+tr[p].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        ll tot=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">pushdown</span>(p);</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=mid) tot+=<span class="built_in">query</span>(lc,l,r);</span><br><span class="line">        <span class="keyword">if</span>(r&gt;mid) tot+=<span class="built_in">query</span>(rc,l,r);</span><br><span class="line">        <span class="keyword">return</span> tot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;trees[<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">19</span>;i++)&#123;</span><br><span class="line">        trees[i].<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n,i);</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> op,l,r,x;</span><br><span class="line">        cin&gt;&gt;op;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">            cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">            ll res=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">19</span>;i++)&#123;</span><br><span class="line">                res+=(<span class="number">1ll</span>&lt;&lt;i)*trees[i].<span class="built_in">query</span>(<span class="number">1</span>,l,r);</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;res&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)&#123;</span><br><span class="line">            cin&gt;&gt;l&gt;&gt;r&gt;&gt;x;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">19</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(x&gt;&gt;i&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                    trees[i].<span class="built_in">update</span>(<span class="number">1</span>,l,r);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ST表"><a href="#ST表" class="headerlink" title="ST表"></a>ST表</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;f[i][<span class="number">0</span>];</span><br><span class="line"><span class="comment">//预处理</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">17</span>;j++)&#123; <span class="comment">//这里的长度是根据区间最大长度取log2算出来的</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n;i++)&#123; <span class="comment">//注意这里要写-1</span></span><br><span class="line">        f[i][j]=<span class="built_in">max</span>(f[i][j<span class="number">-1</span>],f[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line">    <span class="type">int</span> l,r,k;</span><br><span class="line">    cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">    k=<span class="built_in">log2</span>(r-l<span class="number">+1</span>);</span><br><span class="line">    cout&lt;&lt;<span class="built_in">max</span>(f[l][k],f[r-(<span class="number">1</span>&lt;&lt;k)<span class="number">+1</span>][k])&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>


                    
                </div>

                
                        
<div class="post-copyright-info-container border-box">
    <div class="copyright-info-content border-box">
        <div class="copyright-info-top border-box">
            <div class="copyright-post-title border-box text-ellipsis">
                算法竞赛模板
            </div>

            <div class="copyright-post-link border-box text-ellipsis">
                2024/11/21/算法竞赛模板/
            </div>
        </div>

        <div class="copyright-info-bottom border-box">
            <div class="copyright-post-author bottom-item">
                <div class="type">
                    作者
                </div>
                <div class="content">Zack Young</div>
            </div>

            <div class="post-time bottom-item">
                <div class="type">
                    发布于
                </div>
                <div class="content">2024-11-21 19:59</div>
            </div>


            <div class="post-license bottom-item">
                <div class="type">
                    许可
                </div>
                <div class="content tooltip" data-tooltip-content="CC BY-NC-SA 4.0">
                    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans" target="_blank">
                        
                            <i class="fa-brands fa-creative-commons"></i>
                            <i class="fa-brands fa-creative-commons-by"></i>
                            <i class="fa-brands fa-creative-commons-nc"></i>
                            <i class="fa-brands fa-creative-commons-sa"></i>
                        
                    </a>
                </div>
            </div>
        </div>

        <i class="copyright-bg fa-solid fa-copyright"></i>
    </div>
    <div class="copy-copyright-info flex-center tooltip" data-tooltip-content="复制版权信息" data-tooltip-offset-y="-2px">
        <i class="fa-solid fa-copy"></i>
    </div>
</div>

                

                <div class="post-bottom-tags-and-share border-box">
                    <div>
                        
                            <ul class="post-tags-box border-box">
                                
                                    <li class="tag-item border-box">
                                        <i class="icon fas fa-hashtag"></i>&nbsp;<a href="/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B-acm/">算法竞赛 acm</a>
                                    </li>
                                
                            </ul>
                        
                    </div>
                    <div>
                        
                            <div class="post-share-container border-box">
    <ul class="share-list-wrap border-box">
        <li class="qq share-item border-box flex-center tooltip"
            data-tooltip-content="分享到 QQ"
        >
            <i class="fa-brands fa-qq"></i>
        </li>
        <li class="wechat share-item border-box flex-center tooltip tooltip-img"
            data-tooltip-content="分享到微信"
            data-tooltip-img-tip="微信扫一扫"
            data-tooltip-img-style="background-color: #fff; top: -10px; padding: 0.6rem 0.6rem 0.1rem 0.6rem;"
        >
            <i class="fa-brands fa-weixin"></i>
        </li>
        <li class="weibo share-item border-box flex-center tooltip"
            data-tooltip-content="分享到微博"
        >
            <i class="fa-brands fa-weibo"></i>
        </li>
    </ul>
</div>

                        
                    </div>
                </div>

                

                

                
                    






                
            </div>
        </div>

        
            <div class="pc-post-toc right-toc">
                <div class="post-toc-wrap border-box">
    <div class="post-toc border-box">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E6%A8%A1%E6%9D%BF"><span class="nav-text">算法竞赛模板</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF"><span class="nav-text">常见错误</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E8%AF%BB"><span class="nav-text">快读</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E5%AD%A6"><span class="nav-text">数学</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="nav-text">快速幂</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AC%A7%E6%8B%89%E7%BA%BF%E6%80%A7%E7%AD%9B%E6%B3%95"><span class="nav-text">欧拉线性筛法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%A6%E4%B9%9D%E9%9F%B6%E7%AE%97%E6%B3%95"><span class="nav-text">秦九韶算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%88%86"><span class="nav-text">二分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-text">双指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="nav-text">单调队列&#x2F;滑动窗口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%B4%E6%8A%A4%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="nav-text">维护窗口的最小值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%B4%E6%8A%A4%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="nav-text">维护窗口的最大值</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6"><span class="nav-text">高精度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E6%B3%95"><span class="nav-text">高精度加法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%87%8F%E6%B3%95"><span class="nav-text">高精度减法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6%E4%B9%98%E6%B3%95"><span class="nav-text">高精度乘法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6%E9%99%A4%E4%BB%A5%E4%BD%8E%E7%B2%BE%E5%BA%A6"><span class="nav-text">高精度除以低精度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#KMP"><span class="nav-text">KMP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C"><span class="nav-text">字符串哈希</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F%E5%AD%98%E5%9B%BE"><span class="nav-text">链式前向星存图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-text">拓扑排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Kahn-%E5%8D%A1%E6%81%A9-%E7%AE%97%E6%B3%95"><span class="nav-text">Kahn(卡恩)算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF"><span class="nav-text">最短路</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF-Djikstra"><span class="nav-text">单源最短路- Djikstra</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF-Spfa"><span class="nav-text">单源最短路- Spfa</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF-Floyd"><span class="nav-text">全源最短路-Floyd</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-text">最小生成树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Prim%E7%AE%97%E6%B3%95%EF%BC%88%E5%8A%A0%E7%82%B9%E6%B3%95%EF%BC%89"><span class="nav-text">Prim算法（加点法）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Kruskal%E7%AE%97%E6%B3%95%EF%BC%88%E5%8A%A0%E8%BE%B9%E6%B3%95%EF%BC%89"><span class="nav-text">Kruskal算法（加边法）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="nav-text">并查集</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="nav-text">普通并查集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E5%9F%9F%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="nav-text">扩展域并查集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%A6%E6%9D%83%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="nav-text">带权并查集</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86-priority-queue"><span class="nav-text">堆 priority_queue</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E9%87%8D%E8%BD%BD"><span class="nav-text">成员函数内部重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%96%E9%83%A8%E9%87%8D%E8%BD%BD"><span class="nav-text">外部重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E6%A0%B9%E5%A0%86"><span class="nav-text">小根堆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E9%A1%B6%E5%A0%86"><span class="nav-text">对顶堆</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%ACk%E5%A4%A7"><span class="nav-text">第k大</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%ACk%E5%B0%8F"><span class="nav-text">第k小</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="nav-text">线段树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="nav-text">普通线段树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%A6%E4%B9%98%E6%B3%95%E7%9A%84%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="nav-text">带乘法的线段树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B1%82%E5%A4%9A%E6%AE%B5%E5%8C%BA%E9%97%B4%E5%86%85%E4%B8%8D%E5%90%8C%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="nav-text">求多段区间内不同元素的个数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%83%E5%80%BC%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="nav-text">权值线段树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%BA%E9%97%B4%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C"><span class="nav-text">区间最大子段和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%86%E4%BD%8D%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="nav-text">拆位线段树</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ST%E8%A1%A8"><span class="nav-text">ST表</span></a></li></ol></li></ol>
    </div>
</div>

            </div>
        
    </div>
</div>


                
            </div>
        </div>

        <div class="page-main-content-bottom border-box">
            
<footer class="footer border-box">
    <div class="copyright-info info-item">
        &copy;&nbsp;<span>2024</span>&nbsp;-&nbsp;2024
        
            &nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;&nbsp;<a href="/">Zack Young</a>
        
    </div>

    <div class="theme-info info-item">
        由&nbsp;<a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;驱动&nbsp;&&nbsp;主题&nbsp;<a class="keep-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep</a>
    </div>

    
        
        <div class="deploy-info info-item">
            
            本站由 <span class="tooltip" data-tooltip-content="GitHub Pages"><img src="/images/brands/github.png"></span> 提供部署服务
            
        </div>
    

    

    
</footer>

        </div>
    </div>

    <!-- post tools -->
    
        <div class="post-tools right-toc">
            <div class="post-tools-container border-box">
    <ul class="post-tools-list border-box">
        <!-- PC encrypt again -->
        

        <!-- PC TOC show toggle -->
        
            <li class="tools-item flex-center toggle-show-toc">
                <i class="fas fa-list"></i>
            </li>
        

        <!-- PC go comment -->
        

        <!-- PC full screen -->
        <li class="tools-item flex-center full-screen">
            <i class="fa-solid fa-expand"></i>
        </li>
    </ul>
</div>

        </div>
    

    <!-- side tools -->
    <div class="side-tools">
        <div class="side-tools-container border-box ">
    <ul class="side-tools-list side-tools-show-handle border-box">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <!-- toggle mode -->
        
            <li class="tools-item tool-toggle-theme-mode flex-center">
                <i class="fas fa-moon"></i>
            </li>
        

        <!-- rss -->
        

        <!-- to bottom -->
        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list border-box">
        
            <li class="tools-item toggle-show-toc-tablet flex-center">
                <i class="fas fa-list"></i>
            </li>
        

        

        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>

        <li class="tools-item tool-scroll-to-top flex-center show-arrow">
            <i class="arrow fas fa-arrow-up"></i>
            <span class="percent"></span>
        </li>
    </ul>
</div>

    </div>

    <!-- image mask -->
    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    <!-- local search -->
    

    <!-- tablet toc -->
    
        <div class="tablet-post-toc-mask">
            <div class="tablet-post-toc">
                <div class="post-toc-wrap border-box">
    <div class="post-toc border-box">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E6%A8%A1%E6%9D%BF"><span class="nav-text">算法竞赛模板</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF"><span class="nav-text">常见错误</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E8%AF%BB"><span class="nav-text">快读</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E5%AD%A6"><span class="nav-text">数学</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="nav-text">快速幂</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AC%A7%E6%8B%89%E7%BA%BF%E6%80%A7%E7%AD%9B%E6%B3%95"><span class="nav-text">欧拉线性筛法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%A6%E4%B9%9D%E9%9F%B6%E7%AE%97%E6%B3%95"><span class="nav-text">秦九韶算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%88%86"><span class="nav-text">二分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-text">双指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="nav-text">单调队列&#x2F;滑动窗口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%B4%E6%8A%A4%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="nav-text">维护窗口的最小值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%B4%E6%8A%A4%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="nav-text">维护窗口的最大值</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6"><span class="nav-text">高精度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E6%B3%95"><span class="nav-text">高精度加法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%87%8F%E6%B3%95"><span class="nav-text">高精度减法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6%E4%B9%98%E6%B3%95"><span class="nav-text">高精度乘法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6%E9%99%A4%E4%BB%A5%E4%BD%8E%E7%B2%BE%E5%BA%A6"><span class="nav-text">高精度除以低精度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#KMP"><span class="nav-text">KMP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C"><span class="nav-text">字符串哈希</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F%E5%AD%98%E5%9B%BE"><span class="nav-text">链式前向星存图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-text">拓扑排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Kahn-%E5%8D%A1%E6%81%A9-%E7%AE%97%E6%B3%95"><span class="nav-text">Kahn(卡恩)算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF"><span class="nav-text">最短路</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF-Djikstra"><span class="nav-text">单源最短路- Djikstra</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF-Spfa"><span class="nav-text">单源最短路- Spfa</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF-Floyd"><span class="nav-text">全源最短路-Floyd</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-text">最小生成树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Prim%E7%AE%97%E6%B3%95%EF%BC%88%E5%8A%A0%E7%82%B9%E6%B3%95%EF%BC%89"><span class="nav-text">Prim算法（加点法）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Kruskal%E7%AE%97%E6%B3%95%EF%BC%88%E5%8A%A0%E8%BE%B9%E6%B3%95%EF%BC%89"><span class="nav-text">Kruskal算法（加边法）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="nav-text">并查集</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="nav-text">普通并查集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E5%9F%9F%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="nav-text">扩展域并查集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%A6%E6%9D%83%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="nav-text">带权并查集</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86-priority-queue"><span class="nav-text">堆 priority_queue</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E9%87%8D%E8%BD%BD"><span class="nav-text">成员函数内部重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%96%E9%83%A8%E9%87%8D%E8%BD%BD"><span class="nav-text">外部重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E6%A0%B9%E5%A0%86"><span class="nav-text">小根堆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E9%A1%B6%E5%A0%86"><span class="nav-text">对顶堆</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%ACk%E5%A4%A7"><span class="nav-text">第k大</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%ACk%E5%B0%8F"><span class="nav-text">第k小</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="nav-text">线段树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="nav-text">普通线段树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%A6%E4%B9%98%E6%B3%95%E7%9A%84%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="nav-text">带乘法的线段树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B1%82%E5%A4%9A%E6%AE%B5%E5%8C%BA%E9%97%B4%E5%86%85%E4%B8%8D%E5%90%8C%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="nav-text">求多段区间内不同元素的个数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%83%E5%80%BC%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="nav-text">权值线段树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%BA%E9%97%B4%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C"><span class="nav-text">区间最大子段和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%86%E4%BD%8D%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="nav-text">拆位线段树</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ST%E8%A1%A8"><span class="nav-text">ST表</span></a></li></ol></li></ol>
    </div>
</div>

            </div>
        </div>
    
</main>





<!-- common js -->

<script src="/js/utils.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/toggle-theme.js"></script>

<script src="/js/code-block.js"></script>

<script src="/js/main.js"></script>

<script src="/js/libs/anime.min.js"></script>


<!-- local search -->


<!-- lazyload -->


<div class="">
    <!-- home page -->
    

    <!-- post page -->
    
        <!-- post-helper -->
        
<script src="/js/post/post-helper.js"></script>


        <!-- toc -->
        
            
<script src="/js/post/toc.js"></script>

        

        <!-- copyright-info -->
        
            
<script src="/js/post/copyright-info.js"></script>

        

        <!-- share -->
        
            
<script src="/js/post/share.js"></script>

        
    

    <!-- categories page -->
    

    <!-- links page -->
    

    <!-- photos page -->
    

    <!-- tools page -->
    
</div>

<!-- mermaid -->


<!-- pjax -->



</body>
</html>
